/*
 * Copyright 2004 Outerthought bvba and Schaubroeck nv
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.outerj.daisy.frontend.editor;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import org.apache.avalon.framework.service.ServiceManager;
import org.apache.cocoon.components.LifecycleHelper;
import org.apache.cocoon.components.flow.util.PipelineUtil;
import org.apache.cocoon.forms.datatype.StaticSelectionList;
import org.apache.cocoon.forms.event.ValueChangedEvent;
import org.apache.cocoon.forms.event.ValueChangedListener;
import org.apache.cocoon.forms.event.ValueChangedListenerEnabled;
import org.apache.cocoon.forms.formmodel.ContainerWidget;
import org.apache.cocoon.forms.formmodel.DataWidget;
import org.apache.cocoon.forms.formmodel.MultiValueField;
import org.apache.cocoon.forms.formmodel.Widget;
import org.apache.cocoon.forms.formmodel.WidgetState;
import org.apache.cocoon.forms.util.StringMessage;
import org.apache.cocoon.forms.validation.WidgetValidator;
import org.apache.cocoon.xml.IncludeXMLConsumer;
import org.apache.commons.collections.MapUtils;
import org.outerj.daisy.frontend.util.XmlObjectXMLizable;
import org.outerj.daisy.publisher.Publisher;
import org.outerj.daisy.repository.Document;
import org.outerj.daisy.repository.Field;
import org.outerj.daisy.repository.HierarchyPath;
import org.outerj.daisy.repository.Repository;
import org.outerj.daisy.repository.RepositoryException;
import org.outerj.daisy.repository.ValueType;
import org.outerj.daisy.repository.VariantKey;
import org.outerj.daisy.repository.schema.FieldType;
import org.outerj.daisy.repository.schema.FieldTypeUse;
import org.outerj.daisy.repository.schema.ListItem;
import org.outerj.daisy.repository.schema.SelectionList;
import org.outerj.daisy.repository.schema.StaticListItemParent;
import org.outerx.daisy.x10Publisher.PublisherRequestDocument;
import org.outerx.daisy.x10Publisher.ResolveDocumentIdsDocument;
import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

/**
 * A default, generic, FieldEditor implementation that is suited for any sort of
 * field. The form template and definition are generated by means of an XSL (via
 * a Cocoon pipeline).
 */
public class DefaultFieldEditor extends AbstractFieldEditor {
    private Map<String, String> properties;
    
    private final String definition;

    private final String template;
    
    private DefaultFieldEditor(FieldTypeUse fieldTypeUse, Map<String, String> properties, DocumentEditorContext documentEditorContext) {
        super(fieldTypeUse, documentEditorContext);
        this.properties = properties;
        this.definition = MapUtils.getString(properties, "definition", "resources/xslt/fieldtype_to_widgetdefinition.xsl");
        this.template = MapUtils.getString(properties, "template", "resources/xslt/fieldtype_to_widgettemplate.xsl");
    }

    public static class Factory implements FieldEditorFactory {
        public FieldEditor getFieldEditor(FieldTypeUse fieldTypeUse, Map<String, String> properties, DocumentEditorContext documentEditorContext) {
            return new DefaultFieldEditor(fieldTypeUse, properties, documentEditorContext);
        }

    }

    public void generateFormTemplateFragment(ContentHandler contentHandler, Locale locale, String displayMode, ServiceManager serviceManager) throws Exception {
        PipelineUtil pipelineUtil = new PipelineUtil();
        try {
            LifecycleHelper.setupComponent(pipelineUtil, documentEditorContext.getLogger(), documentEditorContext.getContext(), documentEditorContext.getServiceManager(), null, false);
            Map<String, Object> viewData = new HashMap<String, Object>();
            viewData.put("displayMode", displayMode);
            viewData.put("fieldTypeUseToWidgetTemplateXsl", template);
            viewData.put("fieldTypeUse", fieldTypeUse);
            viewData.put("fieldTypeUseXml", new XmlObjectXMLizable(getAnnotatedFieldTypeUseXml(locale)));
            if (widget != null) {
                viewData.put("widget", widget);
            }
            pipelineUtil.processToSAX(documentEditorContext.getDaisyCocoonPath() + "/internal/documentEditor/fieldToWidgetTemplate", viewData, new IncludeXMLConsumer(contentHandler));
        } finally {
            LifecycleHelper.dispose(pipelineUtil);
        }
    }

    public void generateFormDefinitionFragment(ContentHandler contentHandler, Locale locale, String displayMode, ServiceManager serviceManager) throws Exception {
        FieldType fieldType = fieldTypeUse.getFieldType();
        if (fieldType.isHierarchical() && fieldType.getValueType() != ValueType.STRING && fieldType.getValueType() != ValueType.LINK)
            throw new RuntimeException("The document editor does currently not support hierarchical fields of type " + fieldType.getValueType());

        PipelineUtil pipelineUtil = new PipelineUtil();
        try {
            LifecycleHelper.setupComponent(pipelineUtil, documentEditorContext.getLogger(), documentEditorContext.getContext(), documentEditorContext.getServiceManager(), null, false);
            Map<String, Object> viewData = new HashMap<String, Object>();
            viewData.put("displayMode", displayMode);
            viewData.put("fieldTypeUseToWidgetDefinitionXsl", definition);
            viewData.put("fieldTypeUse", fieldTypeUse);
            viewData.put("fieldTypeUseXml", new XmlObjectXMLizable(getAnnotatedFieldTypeUseXml(locale)));
            pipelineUtil.processToSAX(documentEditorContext.getDaisyCocoonPath() + "/internal/documentEditor/fieldToWidgetDefinition", viewData, new IncludeXMLConsumer(contentHandler));
        } finally {
            LifecycleHelper.dispose(pipelineUtil);
        }
    }

    public void init(Widget parentWidget, boolean readonly) {
        // Look up and store widget reference
        this.widget = ((ContainerWidget)parentWidget).getChild("field");
        
        FieldType fieldType = fieldTypeUse.getFieldType();

        // set selection list
        SelectionList selectionList = fieldType.getSelectionList();
        if (selectionList != null && !fieldType.getAllowFreeEntry() && !fieldType.getLoadSelectionListAsync()) {
            if (widget instanceof org.apache.cocoon.forms.formmodel.Field) {
                org.apache.cocoon.forms.formmodel.Field field = (org.apache.cocoon.forms.formmodel.Field)widget;
                field.setSelectionList(new SelectionListAdapter(field.getDatatype(), selectionList, true, fieldType.getValueType(), fieldType.isHierarchical(),
                        documentEditorContext.getRepository().getVariantManager(), documentEditorContext.getDocumentBranchId(), documentEditorContext
                                .getDocumentLanguageId()));
            } else if (widget instanceof MultiValueField) {
                MultiValueField field = (MultiValueField)widget;
                field.setSelectionList(new SelectionListAdapter(field.getDatatype(), selectionList, false, fieldType.getValueType(),
                        fieldType.isHierarchical(), documentEditorContext.getRepository().getVariantManager(), documentEditorContext.getDocumentBranchId(),
                        documentEditorContext.getDocumentLanguageId()));
            }
        }

        // for link field types: add validator and value changed listener to
        // load document name(s)
        if (fieldType.getValueType() == ValueType.LINK) {
            widget.addValidator(new LinkValidator(documentEditorContext.getRepository(), fieldType.isHierarchical()));
            if (fieldType.getAllowFreeEntry() || fieldType.getSelectionList() == null || fieldType.getLoadSelectionListAsync())
                ((ValueChangedListenerEnabled)widget).addValueChangedListener(new LinkLabelLoader(documentEditorContext, fieldType.isHierarchical()));
        } else if (fieldType.getLoadSelectionListAsync() && fieldType.getSelectionList() != null) {
            ((ValueChangedListenerEnabled)widget).addValueChangedListener(new LabelLoader());
        }

        widget.setState(readonly ? WidgetState.DISABLED : WidgetState.ACTIVE);
    }

    public void load(Document document) throws Exception {
        FieldType fieldType = fieldTypeUse.getFieldType();
        Field field = document.getField(fieldType.getId());
        Object value = field.getValue();

        Repository repository = documentEditorContext.getRepository();
        if (fieldType.isHierarchical() && fieldType.isMultiValue()) {
            value = HierarchicalFieldHelper.convertHierarchyPathsToString((Object[])value, field.getValueType(), repository);
        } else if (fieldType.isHierarchical()) {
            value = HierarchicalFieldHelper.convertHierarchyPathToString((HierarchyPath)value, field.getValueType(), repository);
        } else if (fieldType.getValueType() == ValueType.LINK) {
            // special handling for link-field type: convert VariantKey objects to string
            if (fieldType.isMultiValue()) {
                Object[] variantKeys = (Object[])value;
                String[] values = new String[variantKeys.length];
                for (int i = 0; i < variantKeys.length; i++) {
                    values[i] = LinkFieldHelper.variantKeyToStringFilterBranchLanguage((VariantKey)variantKeys[i], repository.getVariantManager(), documentEditorContext.getDocumentBranchId(), documentEditorContext.getDocumentLanguageId());
                }
                value = values;
            } else {
                value = LinkFieldHelper.variantKeyToStringFilterBranchLanguage((VariantKey)value, repository.getVariantManager(), documentEditorContext.getDocumentBranchId(), documentEditorContext.getDocumentLanguageId());
            }
        }

        widget.setValue(value);
    }

    @Override
    public String getDefinitionStylesheet() {
        // not used
        return null;
    }

    @Override
    public String getDefinitionTemplate() {
        // not used
        return null;
    }

    @Override
    public String getTemplateStylesheet() {
        // not used
        return null;
    }

    @Override
    public String getTemplateTemplate() {
        // not used
        return null;
    }

    static class LinkValidator implements WidgetValidator {
        private Repository repository;

        private boolean isHierarchical;

        public LinkValidator(Repository repository, boolean isHierarchical) {
            this.repository = repository;
            this.isHierarchical = isHierarchical;
        }

        public boolean validate(Widget widget) {
            return LinkFieldHelper.validate(widget, isHierarchical, repository);
        }
    }

    /**
     * Loads labels for fields or multivalue fields from the Daisy selection
     * list. Also supports string hierarchical fields (link hierarchical fields
     * are handled by LinkLabelLoader)
     */
    class LabelLoader implements ValueChangedListener {

        public void valueChanged(ValueChangedEvent valueChangedEvent) {
            Object value = valueChangedEvent.getNewValue();
            if (value == null) {
                if (valueChangedEvent.getSourceWidget() instanceof org.apache.cocoon.forms.formmodel.Field)
                    valueChangedEvent.getSourceWidget().lookupWidget("../field-label").setValue(null);
                return;
            }

            if (valueChangedEvent.getSourceWidget() instanceof MultiValueField) {
                MultiValueField field = (MultiValueField)valueChangedEvent.getSourceWidget();
                Object[] values = (Object[])field.getValue();
                String[] labels = new String[values.length];
                for (int i = 0; i < values.length; i++)
                    labels[i] = getLabel(values[i], field);

                // Set labels by means of a selection list
                StaticSelectionList selectionList = new StaticSelectionList(field.getDatatype());
                for (int i = 0; i < values.length; i++)
                    selectionList.addItem(values[i], new StringMessage(labels[i]));
                field.setSelectionList(selectionList);
            } else {
                org.apache.cocoon.forms.formmodel.Field field = (org.apache.cocoon.forms.formmodel.Field)valueChangedEvent.getSourceWidget();
                Widget labelWidget = valueChangedEvent.getSourceWidget().lookupWidget("../field-label");
                labelWidget.setValue(getLabel(value, field));
            }
        }

        private String getLabel(Object value, DataWidget field) {
            FieldType fieldType = fieldTypeUse.getFieldType();
            if (fieldType.isHierarchical()) {
                return getHierarchicalLabel((String)value);
            } else {
                String label = fieldType.getSelectionList().getItemLabel(value, documentEditorContext.getLocale());
                if (label == null)
                    label = field.getDatatype().convertToString(value, documentEditorContext.getLocale());
                return label;
            }
        }

        private String getHierarchicalLabel(String value) {
            FieldType fieldType = fieldTypeUse.getFieldType();
            if (fieldType.getValueType() != ValueType.STRING) {
                // Note: link fields are treated in LinkLabelLoader
                throw new RuntimeException("Unexpected valuetype for hierarhical field: " + fieldType.getValueType());
            }

            String[] elements = HierarchicalFieldHelper.parseHierarchicalInput(value);
            String[] labels = getLabelsFromList(elements);
            StringBuilder builder = new StringBuilder();
            for (int i = 0; i < labels.length; i++) {
                if (builder.length() > 0)
                    builder.append(" / ");
                if (labels[i] != null)
                    builder.append(labels[i]);
                else
                    builder.append(elements[i]);
            }

            return builder.toString();
        }

        private String[] getLabelsFromList(String[] elements) {
            String[] labels = new String[elements.length];
            FieldType fieldType = fieldTypeUse.getFieldType();

            if (fieldType.getSelectionList() instanceof org.outerj.daisy.repository.schema.StaticSelectionList) {
                StaticListItemParent item = (org.outerj.daisy.repository.schema.StaticSelectionList)fieldType.getSelectionList();
                for (int i = 0; i < labels.length; i++) {
                    item = item.getItem(elements[i]);
                    if (item == null)
                        break;
                    labels[i] = ((ListItem)item).getLabel(documentEditorContext.getLocale());
                }
            }
            return labels;
        }
    }

    /**
     * A listener for the link fields that retrieves the document names of the
     * link targets.
     */
    class LinkLabelLoader implements ValueChangedListener {
        private DocumentEditorContext documentEditorContext;

        private boolean isHierarchical;

        public LinkLabelLoader(DocumentEditorContext documentEditorContext, boolean isHierarchical) {
            this.documentEditorContext = documentEditorContext;
            this.isHierarchical = isHierarchical;
        }

        public void valueChanged(ValueChangedEvent valueChangedEvent) {
            try {
                Object value = valueChangedEvent.getNewValue();
                if (value == null) {
                    if (valueChangedEvent.getSourceWidget() instanceof org.apache.cocoon.forms.formmodel.Field)
                        valueChangedEvent.getSourceWidget().lookupWidget("../field-label").setValue(null);
                    return;
                }

                if (!(value instanceof Object[])) {
                    value = new Object[] { value };
                }
                Object[] values = (Object[])value;

                // expand hierarchical values
                Object[] expandResult = expandHierarchicalValues(values);
                Object[] expandedValues = (Object[])expandResult[0];
                int[] valueCounts = (int[])expandResult[1];

                // convert strings to VariantKey objects
                expandedValues = parseValues(expandedValues);

                // load the document names
                String[] names = getDocumentNames(expandedValues);

                // possibly overwrite names with labels from selection list, if
                // available
                FieldType fieldType = fieldTypeUse.getFieldType();
                if (fieldType.getSelectionList() instanceof org.outerj.daisy.repository.schema.StaticSelectionList) {
                    getLabelsFromList(expandedValues, names, valueCounts);
                }

                // combine hierarchical values again
                names = mergeHierarchicalValues(names, valueCounts);

                if (valueChangedEvent.getSourceWidget() instanceof MultiValueField) {
                    MultiValueField field = (MultiValueField)valueChangedEvent.getSourceWidget();
                    StaticSelectionList selectionList = new StaticSelectionList(field.getDatatype());
                    for (int i = 0; i < values.length; i++)
                        selectionList.addItem(values[i], new StringMessage(names[i]));
                    field.setSelectionList(selectionList);
                } else {
                    valueChangedEvent.getSourceWidget().lookupWidget("../field-label").setValue(names[0]);
                }
            } catch (Exception e) {
                // ignore (link in wrong format, ...)
            }
        }

        private String[] getDocumentNames(Object[] values) throws RepositoryException, SAXException {
            PublisherRequestDocument pubReqDoc = PublisherRequestDocument.Factory.newInstance();
            PublisherRequestDocument.PublisherRequest pubReq = pubReqDoc.addNewPublisherRequest();
            ResolveDocumentIdsDocument.ResolveDocumentIds resolveDocIds = pubReq.addNewResolveDocumentIds();
            resolveDocIds.setBranch(String.valueOf(documentEditorContext.getDocumentBranchId()));
            resolveDocIds.setLanguage(String.valueOf(documentEditorContext.getDocumentLanguageId()));

            for (Object value : values) {
                VariantKey variantKey = (VariantKey)value;
                ResolveDocumentIdsDocument.ResolveDocumentIds.Document doc = resolveDocIds.addNewDocument();
                doc.setId(variantKey.getDocumentId());
                if (variantKey.getBranchId() != -1)
                    doc.setBranch(String.valueOf(variantKey.getBranchId()));
                if (variantKey.getLanguageId() != -1)
                    doc.setLanguage(String.valueOf(variantKey.getLanguageId()));
            }

            Publisher publisher = (Publisher)documentEditorContext.getRepository().getExtension("Publisher");
            DocNamesReceiver docNamesReceiver = new DocNamesReceiver(values.length);
            publisher.processRequest(pubReqDoc, docNamesReceiver);
            return docNamesReceiver.getNames();
        }

        private void getLabelsFromList(Object[] values, String[] labels, int[] valueCounts) {
            FieldType fieldType = fieldTypeUse.getFieldType();
            SelectionList selectionList = fieldType.getSelectionList();
            int c = 0;
            for (int i = 0; i < valueCounts.length; i++) {
                if (valueCounts[i] == 1) {
                    VariantKey variantKey = (VariantKey)values[i];
                    String label = selectionList.getItemLabel(variantKey, documentEditorContext.getLocale());
                    if (label != null) {
                        labels[i] = label;
                    }
                } else {
                    getLabelsFromList(values, labels, c, valueCounts[i]);
                }
                c += valueCounts[i];
            }
        }

        /**
         * Treats the values in the elements array from start to length as a
         * hierarchical path, loads the labels of these elements and stores them
         * in the labels array.
         */
        private void getLabelsFromList(Object[] elements, String[] labels, int start, int length) {
            FieldType fieldType = fieldTypeUse.getFieldType();
            if (fieldType.getSelectionList() instanceof org.outerj.daisy.repository.schema.StaticSelectionList) {
                StaticListItemParent item = (org.outerj.daisy.repository.schema.StaticSelectionList)fieldType.getSelectionList();
                for (int i = start; i < start + length; i++) {
                    item = item.getItem(elements[i]);
                    if (item == null)
                        break;
                    String label = ((ListItem)item).getLabel(documentEditorContext.getLocale());
                    if (label != null)
                        labels[i] = label;
                }
            }
        }

        private Object[] parseValues(Object[] values) {
            Object[] result = new Object[values.length];
            for (int i = 0; i < values.length; i++) {
                result[i] = LinkFieldHelper.parseVariantKey((String)values[i], documentEditorContext.getRepository().getVariantManager());
            }
            return result;
        }

        private Object[] expandHierarchicalValues(Object[] values) {
            if (isHierarchical) {
                List<Object> expandedValues = new ArrayList<Object>();
                int[] valueCounts = new int[values.length];
                for (int i = 0; i < values.length; i++) {
                    String input = (String)values[i];
                    String[] parts = HierarchicalFieldHelper.parseHierarchicalInput(input);
                    int counter = 0;
                    for (String part : parts) {
                        expandedValues.add(part);
                        counter++;
                    }
                    valueCounts[i] = counter;
                }
                return new Object[] { expandedValues.toArray(), valueCounts };
            } else {
                int[] valueCounts = new int[values.length];
                for (int i = 0; i < valueCounts.length; i++)
                    valueCounts[i] = 1;
                return new Object[] { values, valueCounts };
            }
        }

        private String[] mergeHierarchicalValues(String[] names, int[] valueCounts) {
            String[] result = new String[valueCounts.length];
            int counter = 0;
            for (int i = 0; i < valueCounts.length; i++) {
                if (valueCounts[i] == 1) {
                    result[i] = names[counter];
                    counter++;
                } else {
                    StringBuilder builder = new StringBuilder();
                    for (int k = 0; k < valueCounts[i]; k++) {
                        if (k > 0)
                            builder.append(" / ");
                        builder.append(names[counter]);
                        counter++;
                    }
                    result[i] = builder.toString();
                }
            }
            return result;
        }
    }

    static class DocNamesReceiver extends DefaultHandler {
        private String[] names;

        private int pos = 0;

        public DocNamesReceiver(int count) {
            this.names = new String[count];
        }

        public String[] getNames() {
            return names;
        }

        public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
            if (uri.equals("http://outerx.org/daisy/1.0#publisher") && localName.equals("document")) {
                names[pos++] = attributes.getValue("name");
            }
        }
    }
    

    
}